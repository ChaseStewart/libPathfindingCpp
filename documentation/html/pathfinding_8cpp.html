<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libPathfindingCpp: /home/vtrre/Projects/GitHub/libPathfindingCpp/libpathfinding/pathfinding.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libPathfindingCpp
   </div>
   <div id="projectbrief">A shared library to perform multi-agent multi-target pathfinding around obstacles</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('pathfinding_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pathfinding.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Library source for libpathfinding.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;boost/geometry.hpp&gt;</code><br />
<code>#include &lt;boost/geometry/geometries/point_xy.hpp&gt;</code><br />
<code>#include &lt;boost/geometry/io/dsv/write.hpp&gt;</code><br />
<code>#include &quot;<a class="el" href="pathfinding_8hpp_source.html">pathfinding.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pathfinding.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="pathfinding_8cpp__incl.png" border="0" usemap="#a_2home_2vtrre_2Projects_2GitHub_2libPathfindingCpp_2libpathfinding_2pathfinding_8cpp" alt=""/></div>
<map name="a_2home_2vtrre_2Projects_2GitHub_2libPathfindingCpp_2libpathfinding_2pathfinding_8cpp" id="a_2home_2vtrre_2Projects_2GitHub_2libPathfindingCpp_2libpathfinding_2pathfinding_8cpp">
<area shape="rect" title="Library source for libpathfinding." alt="" coords="236,5,455,60"/>
<area shape="rect" title=" " alt="" coords="5,115,85,141"/>
<area shape="poly" title=" " alt="" coords="260,63,105,111,95,114,93,109,103,105,258,58"/>
<area shape="rect" title=" " alt="" coords="75,203,138,229"/>
<area shape="poly" title=" " alt="" coords="237,59,190,80,150,110,136,128,125,149,113,190,108,189,120,147,131,125,146,106,188,75,235,55"/>
<area shape="rect" title=" " alt="" coords="408,115,467,141"/>
<area shape="poly" title=" " alt="" coords="373,58,418,103,414,107,370,62"/>
<area shape="rect" title=" " alt="" coords="491,115,554,141"/>
<area shape="poly" title=" " alt="" coords="396,58,490,107,488,111,394,62"/>
<area shape="rect" title=" " alt="" coords="162,203,313,229"/>
<area shape="poly" title=" " alt="" coords="339,61,321,104,297,149,261,195,256,192,292,147,316,101,334,59"/>
<area shape="rect" title=" " alt="" coords="337,196,540,236"/>
<area shape="poly" title=" " alt="" coords="358,59,398,147,420,183,416,186,394,149,353,61"/>
<area shape="rect" title=" " alt="" coords="579,108,747,148"/>
<area shape="poly" title=" " alt="" coords="435,57,586,102,585,107,434,63"/>
<area shape="rect" href="pathfinding_8hpp.html" title="Library header file for libpathfinding." alt="" coords="160,115,283,141"/>
<area shape="poly" title=" " alt="" coords="312,62,250,109,246,105,309,58"/>
<area shape="poly" title=" " alt="" coords="207,143,135,197,131,193,204,139"/>
<area shape="poly" title=" " alt="" coords="226,140,235,189,230,190,221,141"/>
<area shape="poly" title=" " alt="" coords="252,138,379,188,377,193,250,143"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aabb3fd94c8ce7fa3e87ad990f7d45850" id="r_aabb3fd94c8ce7fa3e87ad990f7d45850"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#aabb3fd94c8ce7fa3e87ad990f7d45850">swap_agents</a> (vector&lt; <a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> &gt; &amp;pr, int idx_1, int idx_2)</td></tr>
<tr class="memdesc:aabb3fd94c8ce7fa3e87ad990f7d45850"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchange agents between two final pathfinding results Throws std::out_of_range if idx_1 or idx_2 &gt;= size()  <br /></td></tr>
<tr class="separator:aabb3fd94c8ce7fa3e87ad990f7d45850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae717939d7ef351d5ee5db98638de2fd5" id="r_ae717939d7ef351d5ee5db98638de2fd5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#ae717939d7ef351d5ee5db98638de2fd5">get_obstacle_avoid_path</a> (<a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> straight_path, vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;obstacles, bool is_clockwise)</td></tr>
<tr class="memdesc:ae717939d7ef351d5ee5db98638de2fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the curved line path that avoids obstacles for a single agent Steps are: create union of straight_path and obstacles, get convex hull of union, create resulting path from a subset of convex_hull points and start/end.  <br /></td></tr>
<tr class="separator:ae717939d7ef351d5ee5db98638de2fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16429218fd9dc557bed134792a10c93f" id="r_a16429218fd9dc557bed134792a10c93f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a16429218fd9dc557bed134792a10c93f">find_convex_hull_subset</a> (<a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> agent, <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> target, <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> convex_hull, bool is_clockwise)</td></tr>
<tr class="memdesc:a16429218fd9dc557bed134792a10c93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a convex hull, agent, and target, find subset of points from agent to target this involves finding closest point in convex hull to agent and target, and taking a subvector  <br /></td></tr>
<tr class="separator:a16429218fd9dc557bed134792a10c93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8473addaea09794238f568b9d1b9dd4a" id="r_a8473addaea09794238f568b9d1b9dd4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a8473addaea09794238f568b9d1b9dd4a">calculate_path</a> (<a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;bounds, <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> agent, <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> target, vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;obstacles)</td></tr>
<tr class="memdesc:a8473addaea09794238f568b9d1b9dd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a path from agent to target, this is sort of a state machine that selects straight or curved path, and then orchestrates curved path design if necessary.  <br /></td></tr>
<tr class="separator:a8473addaea09794238f568b9d1b9dd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965b2b061109d103b1b47bdf20340402" id="r_a965b2b061109d103b1b47bdf20340402"><td class="memItemLeft" align="right" valign="top">static vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a965b2b061109d103b1b47bdf20340402">get_intersecting_obstacles</a> (<a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> path, vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; obstacles)</td></tr>
<tr class="memdesc:a965b2b061109d103b1b47bdf20340402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a provided path crosses one or more obstacles.  <br /></td></tr>
<tr class="separator:a965b2b061109d103b1b47bdf20340402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7c55650066f36d71ff67781c4cd469" id="r_a1e7c55650066f36d71ff67781c4cd469"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a1e7c55650066f36d71ff67781c4cd469">is_path_crossing</a> (<a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> p1, <a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> p2)</td></tr>
<tr class="memdesc:a1e7c55650066f36d71ff67781c4cd469"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether two paths intersect  <br /></td></tr>
<tr class="separator:a1e7c55650066f36d71ff67781c4cd469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcf6ef1d57037e2c8cbbdfa84d95b5e" id="r_addcf6ef1d57037e2c8cbbdfa84d95b5e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#addcf6ef1d57037e2c8cbbdfa84d95b5e">is_path_in_bounds</a> (<a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> path, <a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> bounds)</td></tr>
<tr class="memdesc:addcf6ef1d57037e2c8cbbdfa84d95b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether any point in a path ever leaves the boundary.  <br /></td></tr>
<tr class="separator:addcf6ef1d57037e2c8cbbdfa84d95b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e977121b0b26b14af224170e533b3" id="r_a6b3e977121b0b26b14af224170e533b3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a6b3e977121b0b26b14af224170e533b3">is_point_in_bounds</a> (<a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> p, <a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> bounds)</td></tr>
<tr class="memdesc:a6b3e977121b0b26b14af224170e533b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether a point is in bounds  <br /></td></tr>
<tr class="separator:a6b3e977121b0b26b14af224170e533b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb11d95e51504212b4b4a93a26cb4e72" id="r_afb11d95e51504212b4b4a93a26cb4e72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="pathfinding_8hpp.html#a0943e9f7effc752b57932fb71b84b132">MultiPolygon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#afb11d95e51504212b4b4a93a26cb4e72">circle_from_obstacle</a> (<a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> o, double extra_buffer=0)</td></tr>
<tr class="memdesc:afb11d95e51504212b4b4a93a26cb4e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an obstacle into a circular MultiPolygon.  <br /></td></tr>
<tr class="separator:afb11d95e51504212b4b4a93a26cb4e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e65bc6ea74e4f26b0a28313e692ae1" id="r_a02e65bc6ea74e4f26b0a28313e692ae1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a02e65bc6ea74e4f26b0a28313e692ae1">get_obstacle_buffer_size</a> (void)</td></tr>
<tr class="memdesc:a02e65bc6ea74e4f26b0a28313e692ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return an ever-growing amount of keepout as extra buffer around shapes Necessary when multiple agents want to circumvent the same <a class="el" href="pathfinding_8hpp.html#structobstacle" title="a circular &quot;obstacle&quot; with center and radius">obstacle(s)</a> to reach their targets This is fed into circle_from_obstacle's optional arg for <a class="el" href="pathfinding_8cpp.html#ae717939d7ef351d5ee5db98638de2fd5" title="Create the curved line path that avoids obstacles for a single agent Steps are: create union of strai...">get_obstacle_avoid_path()</a>  <br /></td></tr>
<tr class="separator:a02e65bc6ea74e4f26b0a28313e692ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb06f78401961978e5f17e461258e88" id="r_aefb06f78401961978e5f17e461258e88"><td class="memItemLeft" align="right" valign="top"><a id="aefb06f78401961978e5f17e461258e88" name="aefb06f78401961978e5f17e461258e88"></a>
vector&lt; <a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pathfind</b> (<a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;bounds, vector&lt; <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> &gt; &amp;agents, vector&lt; <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> &gt; &amp;targets, vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;obstacles)</td></tr>
<tr class="memdesc:aefb06f78401961978e5f17e461258e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="pathfinding_8cpp.html#aefb06f78401961978e5f17e461258e88" title="the pathfind() function is the core offering of this libpathfinding library see pathfinding....">pathfind()</a> function is the core offering of this libpathfinding library see pathfinding.h and the README.md for details <br /></td></tr>
<tr class="separator:aefb06f78401961978e5f17e461258e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922517e3c331c8e6d70497f405e7c063" id="r_a922517e3c331c8e6d70497f405e7c063"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a922517e3c331c8e6d70497f405e7c063">is_valid_input_params</a> (<a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;bounds, vector&lt; <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> &gt; &amp;agents, vector&lt; <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> &gt; &amp;targets, vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;obstacles)</td></tr>
<tr class="memdesc:a922517e3c331c8e6d70497f405e7c063"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate the input agents and targets.  <br /></td></tr>
<tr class="separator:a922517e3c331c8e6d70497f405e7c063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef56b14dc14713de31633af21e55907" id="r_aaef56b14dc14713de31633af21e55907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#aaef56b14dc14713de31633af21e55907">print_result</a> (<a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;bounds, vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;obstacles, vector&lt; <a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> &gt; &amp;results)</td></tr>
<tr class="separator:aaef56b14dc14713de31633af21e55907"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a91d4a2ffe7310f1e5d315f1247e47bc4" id="r_a91d4a2ffe7310f1e5d315f1247e47bc4"><td class="memItemLeft" align="right" valign="top"><a id="a91d4a2ffe7310f1e5d315f1247e47bc4" name="a91d4a2ffe7310f1e5d315f1247e47bc4"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>points_per_circle</b> = 16</td></tr>
<tr class="memdesc:a91d4a2ffe7310f1e5d315f1247e47bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">configurable number of points around circles <br /></td></tr>
<tr class="separator:a91d4a2ffe7310f1e5d315f1247e47bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5a2b708aba3a6a25b0b802742c5e53" id="r_a7f5a2b708aba3a6a25b0b802742c5e53"><td class="memItemLeft" align="right" valign="top"><a id="a7f5a2b708aba3a6a25b0b802742c5e53" name="a7f5a2b708aba3a6a25b0b802742c5e53"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>line_buffer_distance</b> = 0.1</td></tr>
<tr class="memdesc:a7f5a2b708aba3a6a25b0b802742c5e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">configurable relatively small "stroke-width" to turn lines to polygons <br /></td></tr>
<tr class="separator:a7f5a2b708aba3a6a25b0b802742c5e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b9b3f0c920296d35b9f05c28e0c5e" id="r_a578b9b3f0c920296d35b9f05c28e0c5e"><td class="memItemLeft" align="right" valign="top"><a id="a578b9b3f0c920296d35b9f05c28e0c5e" name="a578b9b3f0c920296d35b9f05c28e0c5e"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>min_keepout_buffer</b> = 0.05</td></tr>
<tr class="memdesc:a578b9b3f0c920296d35b9f05c28e0c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar for <a class="el" href="pathfinding_8cpp.html#a02e65bc6ea74e4f26b0a28313e692ae1" title="return an ever-growing amount of keepout as extra buffer around shapes Necessary when multiple agents...">get_obstacle_buffer_size()</a> <br /></td></tr>
<tr class="separator:a578b9b3f0c920296d35b9f05c28e0c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0274e1e03331bac03de0e17fcefa14ea" id="r_a0274e1e03331bac03de0e17fcefa14ea"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pathfinding_8cpp.html#a0274e1e03331bac03de0e17fcefa14ea">buffer_offset</a> = 1</td></tr>
<tr class="memdesc:a0274e1e03331bac03de0e17fcefa14ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">static variable, ensures n-many wraps around obstacles don't take same path each subsequent call to get_obstacle_avoid_path will have additional keepout  <br /></td></tr>
<tr class="separator:a0274e1e03331bac03de0e17fcefa14ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Library source for libpathfinding. </p>
<dl class="section author"><dt>Author</dt><dd>Chase E. Stewart </dd></dl>
<dl class="section date"><dt>Date</dt><dd>4/24/2025 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8473addaea09794238f568b9d1b9dd4a" name="a8473addaea09794238f568b9d1b9dd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8473addaea09794238f568b9d1b9dd4a">&#9670;&#160;</a></span>calculate_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> calculate_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a>&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a path from agent to target, this is sort of a state machine that selects straight or curved path, and then orchestrates curved path design if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>outer bounding Box </td></tr>
    <tr><td class="paramname">agent</td><td>agent that must route to target </td></tr>
    <tr><td class="paramname">target</td><td>target to be routed to </td></tr>
    <tr><td class="paramname">obstacles</td><td>vector of circular obstacles to avoid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new straight or curved path from agent to target </dd></dl>
<p>Easy case: a straight line to the target will always be the best bid for a particular agent if it is avaialable</p>
<p>Hard case: if even one obstacle intersects the path, curved object-avoiding path is needed</p>

</div>
</div>
<a id="afb11d95e51504212b4b4a93a26cb4e72" name="afb11d95e51504212b4b4a93a26cb4e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb11d95e51504212b4b4a93a26cb4e72">&#9670;&#160;</a></span>circle_from_obstacle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pathfinding_8hpp.html#a0943e9f7effc752b57932fb71b84b132">MultiPolygon</a> circle_from_obstacle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>extra_buffer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn an obstacle into a circular MultiPolygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>obstacle to become a circle </td></tr>
    <tr><td class="paramname">extra_buffer</td><td>optionally increase buffer around obstacle. See <a class="el" href="pathfinding_8cpp.html#a02e65bc6ea74e4f26b0a28313e692ae1" title="return an ever-growing amount of keepout as extra buffer around shapes Necessary when multiple agents...">get_obstacle_buffer_size()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MultiPolygon circular polygon made of 16 evenly spaced points around o.p </dd></dl>
<p>We use the concept of a buffer around a point to create our circle boost::geometry strategies are effectively options about how we will generate our circle</p>

</div>
</div>
<a id="a16429218fd9dc557bed134792a10c93f" name="a16429218fd9dc557bed134792a10c93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16429218fd9dc557bed134792a10c93f">&#9670;&#160;</a></span>find_convex_hull_subset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> find_convex_hull_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a>&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td>
          <td class="paramname"><em>convex_hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_clockwise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>given a convex hull, agent, and target, find subset of points from agent to target this involves finding closest point in convex hull to agent and target, and taking a subvector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the Point of the agent, first point in straight_path </td></tr>
    <tr><td class="paramname">target</td><td>the Point of the final target, second and final point in straight_path </td></tr>
    <tr><td class="paramname">convex_hull</td><td>a closed-shape convex hull that goes around but doesn't touch agent/target </td></tr>
    <tr><td class="paramname">is_clockwise</td><td>true to reverse convex_hull before iterating </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Line with the relevant portion of provided convex_hull for pathfinding </dd></dl>
<p>iterate around whole closed shape, checking each points distances to agent and to target, keep a running tally of closest point to each</p>
<p>now that we have closest points, return subset of closed shape from min(start,end) to max(start,end) TODO this is suboptimal and it should be possible to reason out this min/max/ reverse issue</p>

</div>
</div>
<a id="a965b2b061109d103b1b47bdf20340402" name="a965b2b061109d103b1b47bdf20340402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965b2b061109d103b1b47bdf20340402">&#9670;&#160;</a></span>get_intersecting_obstacles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; get_intersecting_obstacles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt;&#160;</td>
          <td class="paramname"><em>obstacles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a provided path crosses one or more obstacles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Line from target to agent to check for obstacles </td></tr>
    <tr><td class="paramname">obstacles</td><td>A vector of circular obstacles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of intersecting obstacles, empty if no intersection </dd></dl>
<p>rather than check whether every point or n-many points along the line is within a particular radius, we instead create a circle as a keepout buffer around a point and then use the boost::geometry intersection checker</p>

</div>
</div>
<a id="ae717939d7ef351d5ee5db98638de2fd5" name="ae717939d7ef351d5ee5db98638de2fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae717939d7ef351d5ee5db98638de2fd5">&#9670;&#160;</a></span>get_obstacle_avoid_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a> get_obstacle_avoid_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td>
          <td class="paramname"><em>straight_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_clockwise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the curved line path that avoids obstacles for a single agent Steps are: create union of straight_path and obstacles, get convex hull of union, create resulting path from a subset of convex_hull points and start/end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">straight_path</td><td>a two-point line with {agent, target} </td></tr>
    <tr><td class="paramname">obstacles</td><td>vector of all obstacles </td></tr>
    <tr><td class="paramname">is_clockwise</td><td>true to reverse the convex_hull output before iterating </td></tr>
  </table>
  </dd>
</dl>
<p>iteratively create a polygon union of all obstacles intersecting with the straight line path we expect to have at least one, or else we would have used pathfinding()'s straight_path</p>
<p>create an ever-slightly-wider circle (see get_obstacle_buffer_size) and stick it to our thin line_buf polygon</p>
<p>now the rest of the algorithm is going to be about effectively selecting a subset of the convex hull and making sure it exactly reaches our points</p>
<p>with infinite time I'd like to figure out why I have so much trouble with order of these points- but this works in a nutshell- if it appears clear we hop from the first point to the far end of the convex hull and vice versa, and thus this path crosses itself, just reverse it</p>
<p>because we're making a convex hull around a stroked path, there are some annoying small points around the buffer near each endpoint we have this keepout to filter out those noisy parts and just take the path around the <a class="el" href="pathfinding_8hpp.html#structobstacle" title="a circular &quot;obstacle&quot; with center and radius">obstacle(s)</a></p>

</div>
</div>
<a id="a02e65bc6ea74e4f26b0a28313e692ae1" name="a02e65bc6ea74e4f26b0a28313e692ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e65bc6ea74e4f26b0a28313e692ae1">&#9670;&#160;</a></span>get_obstacle_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double get_obstacle_buffer_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return an ever-growing amount of keepout as extra buffer around shapes Necessary when multiple agents want to circumvent the same <a class="el" href="pathfinding_8hpp.html#structobstacle" title="a circular &quot;obstacle&quot; with center and radius">obstacle(s)</a> to reach their targets This is fed into circle_from_obstacle's optional arg for <a class="el" href="pathfinding_8cpp.html#ae717939d7ef351d5ee5db98638de2fd5" title="Create the curved line path that avoids obstacles for a single agent Steps are: create union of strai...">get_obstacle_avoid_path()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>configurable min_buffer value * incrementing buffer_offset var </dd></dl>

</div>
</div>
<a id="a1e7c55650066f36d71ff67781c4cd469" name="a1e7c55650066f36d71ff67781c4cd469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7c55650066f36d71ff67781c4cd469">&#9670;&#160;</a></span>is_path_crossing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool is_path_crossing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a>&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test whether two paths intersect </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>one pathfinding_result, from which path will be obtained </td></tr>
    <tr><td class="paramname">p2</td><td>another pathfinding_result, from which path will be obtained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if p1.path and p2.path intersect, else false </dd></dl>

</div>
</div>
<a id="addcf6ef1d57037e2c8cbbdfa84d95b5e" name="addcf6ef1d57037e2c8cbbdfa84d95b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcf6ef1d57037e2c8cbbdfa84d95b5e">&#9670;&#160;</a></span>is_path_in_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool is_path_in_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a86f22d25652f7746feb05ac4b340086b">Line</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether any point in a path ever leaves the boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path under test </td></tr>
    <tr><td class="paramname">bounds</td><td>outer boundary Box, all points along p should be inside this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if path between {target,agent} never leaves the boundary, else false </dd></dl>

</div>
</div>
<a id="a6b3e977121b0b26b14af224170e533b3" name="a6b3e977121b0b26b14af224170e533b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e977121b0b26b14af224170e533b3">&#9670;&#160;</a></span>is_point_in_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool is_point_in_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test whether a point is in bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>point under test </td></tr>
    <tr><td class="paramname">bounds</td><td>outer boundary Box point p should be inside this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if path never leaves the boundary, else false </dd></dl>

</div>
</div>
<a id="a922517e3c331c8e6d70497f405e7c063" name="a922517e3c331c8e6d70497f405e7c063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922517e3c331c8e6d70497f405e7c063">&#9670;&#160;</a></span>is_valid_input_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid_input_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>agents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#a4495ec0c90a0251fb2ac85a7f673f37e">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>validate the input agents and targets. </p>
<p>If this fails, pathfinding cannot proceed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>Outer boundary box </td></tr>
    <tr><td class="paramname">agents</td><td>vector of all agents </td></tr>
    <tr><td class="paramname">targets</td><td>vector of all targets </td></tr>
    <tr><td class="paramname">obstacles</td><td>vector of all obstacles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if input params are valid, else false </dd></dl>

</div>
</div>
<a id="aaef56b14dc14713de31633af21e55907" name="aaef56b14dc14713de31633af21e55907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef56b14dc14713de31633af21e55907">&#9670;&#160;</a></span>print_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pathfinding_8hpp.html#a58e6558443cd17457f7b993813ae14a9">Boundary</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structobstacle">obstacle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The associated python rendering script render_result.py is designed to ignore blank lines and lines that begin with tab so that output from this library can be read for diagnostic information or simply piped to a .csv to render with the python script</p>

</div>
</div>
<a id="aabb3fd94c8ce7fa3e87ad990f7d45850" name="aabb3fd94c8ce7fa3e87ad990f7d45850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb3fd94c8ce7fa3e87ad990f7d45850">&#9670;&#160;</a></span>swap_agents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void swap_agents </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="pathfinding_8hpp.html#structpathfind__result">pathfind_result</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchange agents between two final pathfinding results Throws std::out_of_range if idx_1 or idx_2 &gt;= size() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pr</td><td>the full pathfinding results </td></tr>
    <tr><td class="paramname">idx_1</td><td>the first index into pr to swap </td></tr>
    <tr><td class="paramname">idx_2</td><td>the second index into pr to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0274e1e03331bac03de0e17fcefa14ea" name="a0274e1e03331bac03de0e17fcefa14ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0274e1e03331bac03de0e17fcefa14ea">&#9670;&#160;</a></span>buffer_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int buffer_offset = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>static variable, ensures n-many wraps around obstacles don't take same path each subsequent call to get_obstacle_avoid_path will have additional keepout </p>
<p>incrementing value to increase subsequent keepout around obstacles </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_11630eba5be63c1f1fa676daa1e18d25.html">libpathfinding</a></li><li class="navelem"><a class="el" href="pathfinding_8cpp.html">pathfinding.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
